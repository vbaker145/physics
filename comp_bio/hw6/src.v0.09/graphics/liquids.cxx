// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "liquids.h"
#include "FL/fl_ask.H"
#include "FL/fl_file_chooser.H"
#include "atom.h"
#include "ensemble.h"
#include "integrator.h"
#include "minima.h"
#include "forces.h"
#include "diffusion.h"
#include "paircorrfunc.h"
#include "R.h"
#include "verletlist.h"
#include "defs.h"
#include <stdlib.h>
#include "gl_obj.h"
static int flag = 0; 
static float freq = 0.001; 
static long bench_t = time(NULL); 
static int bench_h = 100; 
using namespace std;

Fl_Double_Window *setupWin=(Fl_Double_Window *)0;

Fl_Tabs *tabSetup=(Fl_Tabs *)0;

Fl_Group *tabParams=(Fl_Group *)0;

Fl_Value_Input *valueLx=(Fl_Value_Input *)0;

Fl_Value_Input *valueLy=(Fl_Value_Input *)0;

Fl_Value_Input *valueLz=(Fl_Value_Input *)0;

Fl_Value_Input *valueDeltaT=(Fl_Value_Input *)0;

Fl_Value_Input *valueDensity=(Fl_Value_Input *)0;

Fl_Value_Input *valueTotalTime=(Fl_Value_Input *)0;

Fl_Value_Input *valueTemperature=(Fl_Value_Input *)0;

Fl_Group *tabDynamics=(Fl_Group *)0;

Fl_Choice *choiceDynamics=(Fl_Choice *)0;

static void cb_choiceDynamics(Fl_Choice*, void*) {
  choiceDynamicsHideButtons();
}

Fl_Menu_Item menu_choiceDynamics[] = {
 {"0) MD LJ N*(N-1)/2 Calculation", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"1) MD LJ with Rc Potential cutoff", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"2) MD LJ Rc + Verlet Lists", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"3) DMD Hard Spheres", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"4) MD Langevin", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"5) MD Langevin - Method 2", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"6) MC LJ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"7) MC LJ+XY Model", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"8) MC LJ+LL Model", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"9) MC LJ in NPT", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"10) MD LJ N(N-1)/2 POLYMERS", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"11) MD LJ Rc + Verlet Lists Polymers", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Value_Input *valueRcCutoff=(Fl_Value_Input *)0;

Fl_Value_Input *valueRlCutoff=(Fl_Value_Input *)0;

Fl_Value_Input *valueDampingConstant=(Fl_Value_Input *)0;

static void cb_valueDampingConstant(Fl_Value_Input*, void*) {
  valueVelRelaxationTime->value(1./valueDampingConstant->value());
}

Fl_Value_Input *valueVelRelaxationTime=(Fl_Value_Input *)0;

Fl_Value_Input *valueMCStepSize=(Fl_Value_Input *)0;

Fl_Value_Input *valueMCStepSizeTheta=(Fl_Value_Input *)0;

Fl_Check_Button *checkDoMCStepRescale=(Fl_Check_Button *)0;

Fl_Value_Input *valueXYJ=(Fl_Value_Input *)0;

Fl_Group *tabInitPos=(Fl_Group *)0;

Fl_Choice *initPosChoice=(Fl_Choice *)0;

Fl_Menu_Item menu_initPosChoice[] = {
 {"Lattice Positions", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Random Positions", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Two Particles Random", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Two Particles x-axis", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Polymers", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Read From File", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Choice *initVelChoice=(Fl_Choice *)0;

Fl_Menu_Item menu_initVelChoice[] = {
 {"Zero Velocities", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Uniform Random Velocities", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Two Particle", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Polymer", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Value_Input *valueThresholdInitRandPos=(Fl_Value_Input *)0;

Fl_Value_Input *valueTwoPartVel=(Fl_Value_Input *)0;

Fl_Group *tabProteins=(Fl_Group *)0;

Fl_Check_Button *checkPutPolymers=(Fl_Check_Button *)0;

Fl_Value_Input *valueNumChains=(Fl_Value_Input *)0;

Fl_Value_Input *valueNumAtomsPerChain=(Fl_Value_Input *)0;

Fl_Value_Input *valueBondLength=(Fl_Value_Input *)0;

Fl_Group *tabMinimize=(Fl_Group *)0;

Fl_Check_Button *checkSteepDescMinim=(Fl_Check_Button *)0;

Fl_Group *tabMeasures=(Fl_Group *)0;

Fl_Check_Button *checkDoVacf=(Fl_Check_Button *)0;

Fl_Check_Button *checkDoPcf=(Fl_Check_Button *)0;

Fl_Check_Button *checkDoR=(Fl_Check_Button *)0;

Fl_Value_Input *valueTimeMeasure=(Fl_Value_Input *)0;

Fl_Value_Input *valueNHisPcf=(Fl_Value_Input *)0;

Fl_Return_Button *applyParamBut=(Fl_Return_Button *)0;

static void cb_applyParamBut(Fl_Return_Button*, void*) {
  applyParamsButton();
}

Fl_Double_Window *toolsWin=(Fl_Double_Window *)0;

Fl_Tabs *tabTools=(Fl_Tabs *)0;

Fl_Group *tabRunParams=(Fl_Group *)0;

Fl_Value_Output *valueOutputReqTemp=(Fl_Value_Output *)0;

Fl_Value_Output *valueOutputTemp=(Fl_Value_Output *)0;

Fl_Repeat_Button *butScaleTemp=(Fl_Repeat_Button *)0;

static void cb_butScaleTemp(Fl_Repeat_Button*, void*) {
  applyRescaleVels();
}

Fl_Group *tabParticles=(Fl_Group *)0;

Fl_Value_Input *valueTagParticle=(Fl_Value_Input *)0;

Fl_Value_Output *valueTotNumParticles=(Fl_Value_Output *)0;

Fl_Check_Button *checkTagPart=(Fl_Check_Button *)0;

static void cb_checkTagPart(Fl_Check_Button*, void*) {
  applyCheckTagParticle();
}

Fl_Button *butTagPart=(Fl_Button *)0;

static void cb_butTagPart(Fl_Button*, void*) {
  writeTagTrajectory();
}

Fl_Double_Window *mainWin=(Fl_Double_Window *)0;

gl_obj *mainBox=(gl_obj *)0;

static void cb_Read(Fl_Menu_*, void*) {
  ReadPositions();
}

static void cb_Write(Fl_Menu_*, void*) {
  WritePositions(0);
}

static void cb_Quit(Fl_Menu_*, void*) {
  ExitFunc();
}

static void cb_setupParamsMenu(Fl_Menu_*, void*) {
  showParamsWindow();
}

static void cb_writeVelsMenu(Fl_Menu_*, void*) {
  saveAllVels();
}

static void cb_Pause(Fl_Menu_*, void*) {
  Pause();
}

static void cb_Step(Fl_Menu_*, void*) {
  Step();
}

static void cb_Run(Fl_Menu_*, void*) {
  Run();
}

static void cb_toolsDialog(Fl_Menu_*, void*) {
  showToolsWindow();
}

Fl_Menu_Item menu_[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Read Positions", 0,  (Fl_Callback*)cb_Read, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Write Positions", 0,  (Fl_Callback*)cb_Write, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0,  (Fl_Callback*)cb_Quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Params", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Setup Params", 0,  (Fl_Callback*)cb_setupParamsMenu, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Write Velocities", 0,  (Fl_Callback*)cb_writeVelsMenu, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Run", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Pause", 0,  (Fl_Callback*)cb_Pause, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Step", 0,  (Fl_Callback*)cb_Step, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Run", 0,  (Fl_Callback*)cb_Run, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Tools", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Tools Window", 0,  (Fl_Callback*)cb_toolsDialog, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Return_Button *stepButton=(Fl_Return_Button *)0;

static void cb_stepButton(Fl_Return_Button*, void*) {
  Step();
runButton->activate();
}

Fl_Return_Button *runButton=(Fl_Return_Button *)0;

static void cb_runButton(Fl_Return_Button*, void*) {
  runButton->deactivate();
Run();
}

Fl_Value_Output *simuTime=(Fl_Value_Output *)0;

Fl_Spinner *freq_anim=(Fl_Spinner *)0;

static void cb_freq_anim(Fl_Spinner*, void*) {
  freq = freq_anim->value();
}

int main(int argc, char **argv) {
  CLEAN_OUTPUT_FILES
  SET_SEED
  { setupWin = new Fl_Double_Window(425, 395, "Setup Params");
    { tabSetup = new Fl_Tabs(4, 4, 416, 346);
      { tabParams = new Fl_Group(4, 24, 325, 325, "Params");
        { valueLx = new Fl_Value_Input(46, 54, 65, 25, "Lx:");
        } // Fl_Value_Input* valueLx
        { valueLy = new Fl_Value_Input(46, 94, 65, 25, "Ly:");
        } // Fl_Value_Input* valueLy
        { valueLz = new Fl_Value_Input(47, 132, 65, 25, "Lz:");
        } // Fl_Value_Input* valueLz
        { valueDeltaT = new Fl_Value_Input(134, 179, 75, 25, "Delta t:");
        } // Fl_Value_Input* valueDeltaT
        { valueDensity = new Fl_Value_Input(219, 89, 100, 25, "Density:");
        } // Fl_Value_Input* valueDensity
        { valueTotalTime = new Fl_Value_Input(134, 214, 75, 25, "Total Time:");
        } // Fl_Value_Input* valueTotalTime
        { valueTemperature = new Fl_Value_Input(219, 54, 100, 25, "Temperature:");
        } // Fl_Value_Input* valueTemperature
        tabParams->end();
      } // Fl_Group* tabParams
      { tabDynamics = new Fl_Group(4, 24, 326, 325, "Dynamics");
        tabDynamics->hide();
        { choiceDynamics = new Fl_Choice(14, 74, 305, 25, "Force and Integration Dynamics:");
          choiceDynamics->down_box(FL_BORDER_BOX);
          choiceDynamics->callback((Fl_Callback*)cb_choiceDynamics);
          choiceDynamics->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          choiceDynamics->menu(menu_choiceDynamics);
        } // Fl_Choice* choiceDynamics
        { valueRcCutoff = new Fl_Value_Input(40, 125, 115, 25, "Rc Cutoff:");
          valueRcCutoff->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueRcCutoff
        { valueRlCutoff = new Fl_Value_Input(165, 125, 115, 25, "Rl Cutoff:");
          valueRlCutoff->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueRlCutoff
        { valueDampingConstant = new Fl_Value_Input(19, 184, 135, 25, "Damping Constant:");
          valueDampingConstant->callback((Fl_Callback*)cb_valueDampingConstant);
          valueDampingConstant->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueDampingConstant
        { valueVelRelaxationTime = new Fl_Value_Input(164, 185, 135, 25, "Vel. Relaxation Time:");
          valueVelRelaxationTime->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          valueVelRelaxationTime->deactivate();
        } // Fl_Value_Input* valueVelRelaxationTime
        { valueMCStepSize = new Fl_Value_Input(20, 241, 135, 25, "MC Step Size:");
          valueMCStepSize->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueMCStepSize
        { valueMCStepSizeTheta = new Fl_Value_Input(167, 242, 135, 25, "MC Theta Size:");
          valueMCStepSizeTheta->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueMCStepSizeTheta
        { checkDoMCStepRescale = new Fl_Check_Button(163, 269, 70, 15, "Adjust MC Step");
          checkDoMCStepRescale->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkDoMCStepRescale
        { valueXYJ = new Fl_Value_Input(44, 314, 135, 25, "XY Model J:");
          valueXYJ->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueXYJ
        tabDynamics->end();
      } // Fl_Group* tabDynamics
      { tabInitPos = new Fl_Group(4, 24, 325, 325, "Inits");
        tabInitPos->hide();
        { initPosChoice = new Fl_Choice(119, 69, 155, 25, "Positions:");
          initPosChoice->down_box(FL_BORDER_BOX);
          initPosChoice->menu(menu_initPosChoice);
        } // Fl_Choice* initPosChoice
        { initVelChoice = new Fl_Choice(125, 205, 152, 24, "Velocities:");
          initVelChoice->down_box(FL_BORDER_BOX);
          initVelChoice->menu(menu_initVelChoice);
        } // Fl_Choice* initVelChoice
        { valueThresholdInitRandPos = new Fl_Value_Input(60, 130, 215, 30, "Threshold Energy for Rnd Pos.");
          valueThresholdInitRandPos->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueThresholdInitRandPos
        { valueTwoPartVel = new Fl_Value_Input(61, 264, 215, 30, "Two particle up/down speed");
          valueTwoPartVel->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueTwoPartVel
        tabInitPos->end();
      } // Fl_Group* tabInitPos
      { tabProteins = new Fl_Group(4, 24, 326, 325, "Polymers");
        tabProteins->hide();
        { checkPutPolymers = new Fl_Check_Button(75, 50, 185, 15, "Put Proteins");
          checkPutPolymers->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkPutPolymers
        { valueNumChains = new Fl_Value_Input(77, 110, 135, 25, "Number of Chains:");
          valueNumChains->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueNumChains
        { valueNumAtomsPerChain = new Fl_Value_Input(77, 175, 135, 25, "No. Atoms per Chain:");
          valueNumAtomsPerChain->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueNumAtomsPerChain
        { valueBondLength = new Fl_Value_Input(77, 239, 135, 25, "Length of Bonds:");
          valueBondLength->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueBondLength
        tabProteins->end();
      } // Fl_Group* tabProteins
      { tabMinimize = new Fl_Group(4, 24, 325, 325, "Minimize");
        tabMinimize->hide();
        { checkSteepDescMinim = new Fl_Check_Button(60, 80, 165, 15, "Steepest Descent Minimize");
          checkSteepDescMinim->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkSteepDescMinim
        tabMinimize->end();
      } // Fl_Group* tabMinimize
      { tabMeasures = new Fl_Group(4, 24, 325, 325, "Measures");
        tabMeasures->hide();
        { checkDoVacf = new Fl_Check_Button(42, 49, 70, 15, "Do vacf and <r2>");
          checkDoVacf->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkDoVacf
        { checkDoPcf = new Fl_Check_Button(42, 79, 70, 15, "Do pair correlation function");
          checkDoPcf->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkDoPcf
        { checkDoR = new Fl_Check_Button(42, 109, 70, 15, "Do end-to-end and Rg");
          checkDoR->down_box(FL_DOWN_BOX);
        } // Fl_Check_Button* checkDoR
        { valueTimeMeasure = new Fl_Value_Input(14, 173, 65, 25, "Time interval to measure vacf and pcf:");
          valueTimeMeasure->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueTimeMeasure
        { valueNHisPcf = new Fl_Value_Input(14, 247, 65, 25, "Num. bins in pcf histogram:");
          valueNHisPcf->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Input* valueNHisPcf
        tabMeasures->end();
      } // Fl_Group* tabMeasures
      tabSetup->end();
    } // Fl_Tabs* tabSetup
    { applyParamBut = new Fl_Return_Button(176, 355, 72, 30, "Apply");
      applyParamBut->callback((Fl_Callback*)cb_applyParamBut);
    } // Fl_Return_Button* applyParamBut
    setupWin->end();
  } // Fl_Double_Window* setupWin
  { toolsWin = new Fl_Double_Window(335, 355);
    { tabTools = new Fl_Tabs(4, 4, 326, 346);
      { tabRunParams = new Fl_Group(4, 24, 325, 325, "Live Params");
        { valueOutputReqTemp = new Fl_Value_Output(20, 69, 90, 25, "Requested Temperature:");
          valueOutputReqTemp->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Output* valueOutputReqTemp
        { valueOutputTemp = new Fl_Value_Output(20, 123, 90, 25, "Current Temperature:");
          valueOutputTemp->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Value_Output* valueOutputTemp
        { butScaleTemp = new Fl_Repeat_Button(85, 175, 125, 31, "Scale Velocities");
          butScaleTemp->callback((Fl_Callback*)cb_butScaleTemp);
        } // Fl_Repeat_Button* butScaleTemp
        tabRunParams->end();
      } // Fl_Group* tabRunParams
      { tabParticles = new Fl_Group(4, 24, 325, 325, "Tag");
        tabParticles->hide();
        { valueTagParticle = new Fl_Value_Input(130, 100, 55, 25, "Tag Particle #:");
        } // Fl_Value_Input* valueTagParticle
        { valueTotNumParticles = new Fl_Value_Output(130, 55, 55, 25, "Num. Particles:");
        } // Fl_Value_Output* valueTotNumParticles
        { checkTagPart = new Fl_Check_Button(215, 100, 70, 25, "Tag");
          checkTagPart->down_box(FL_DOWN_BOX);
          checkTagPart->callback((Fl_Callback*)cb_checkTagPart);
        } // Fl_Check_Button* checkTagPart
        { butTagPart = new Fl_Button(75, 145, 165, 30, "Write Tag Trajectory");
          butTagPart->callback((Fl_Callback*)cb_butTagPart);
        } // Fl_Button* butTagPart
        tabParticles->end();
      } // Fl_Group* tabParticles
      tabTools->end();
    } // Fl_Tabs* tabTools
    toolsWin->end();
  } // Fl_Double_Window* toolsWin
  { mainWin = new Fl_Double_Window(440, 490, "Liquids");
    { Fl_Box* o = new Fl_Box(21, 34, 402, 402, "label");
      o->box(FL_DOWN_BOX);
    } // Fl_Box* o
    { mainBox = new gl_obj(22, 35, 400, 400, "label");
      mainBox->box(FL_DOWN_BOX);
      mainBox->color(FL_BACKGROUND_COLOR);
      mainBox->selection_color(FL_BACKGROUND_COLOR);
      mainBox->labeltype(FL_NORMAL_LABEL);
      mainBox->labelfont(0);
      mainBox->labelsize(14);
      mainBox->labelcolor(FL_FOREGROUND_COLOR);
      mainBox->align(Fl_Align(FL_ALIGN_CENTER));
      mainBox->when(FL_WHEN_RELEASE);
    } // gl_obj* mainBox
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 440, 20);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { stepButton = new Fl_Return_Button(174, 448, 120, 25, "Step");
      stepButton->callback((Fl_Callback*)cb_stepButton);
      stepButton->deactivate();
    } // Fl_Return_Button* stepButton
    { runButton = new Fl_Return_Button(301, 448, 120, 25, "Run");
      runButton->callback((Fl_Callback*)cb_runButton);
      runButton->deactivate();
    } // Fl_Return_Button* runButton
    { simuTime = new Fl_Value_Output(46, 449, 53, 22, "Time");
    } // Fl_Value_Output* simuTime
    { freq_anim = new Fl_Spinner(111, 450, 50, 20);
      freq_anim->type(1);
      freq_anim->labelsize(7);
      freq_anim->minimum(0.001);
      freq_anim->maximum(0.01);
      freq_anim->step(0.001);
      freq_anim->value(0.001);
      freq_anim->textsize(10);
      freq_anim->callback((Fl_Callback*)cb_freq_anim);
      freq_anim->align(Fl_Align(FL_ALIGN_CENTER));
    } // Fl_Spinner* freq_anim
    mainWin->end();
  } // Fl_Double_Window* mainWin
  mainWin->show(argc,argv);
  mainBox->show();
  mainBox->redraw();
  mainWin->show(argc, argv);
  return Fl::run();
}

void calc(void) {
  // **************************
      // CHOOSE STEPS ACCORDING TO DYNAMICS
      switch(mainBox->sys.dynamics)
      {
      
            case 0:
          {
            // ##################################
            // REGULAR LJ MD, N*(N-1)/2 CALCULATION
            // ##################################
  
            // **************************
            // CALCULATE FORCES
            double virSum;
            mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //    - VERLET ALGORITHM
            mainBox->integrate.verlet(mainBox->sys);
            //    - VELOCITY VERLET ALGORITHM
            //integrate.velocity_verlet(physics, sys);
  
            break;
          }
          case 1:
          {
            // ##################################
            // LJ POTENTIAL CUTOFF AT Rc
            // ##################################
  
            // **************************
            // CALCULATE FORCES
            //mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
            // **************************
            // CALCULATE FORCES HERE ONLY THE FIRST TIME
            if (mainBox->n==0)
            {
              mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
            }
  
            // **************************
            // INTEGRATE EQ. OF MOTION PT 1
            //    - VERLET ALGORITHM
            //integrate.verlet(sys);
            //    - VELOCITY VERLET ALGORITHM
            mainBox->integrate.velocity_verlet_pt1(mainBox->physics, mainBox->sys);
  
            // **************************
            //  CALCULATE FORCES IN BETWEEN
            mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION PT 2
            //    - VELOCITY VERLET ALGORITHM
            mainBox->integrate.velocity_verlet_pt2(mainBox->physics, mainBox->sys);
  
            break;
          }
          case 2:
          {
            // ##################################
            // LJ POTENTIAL CUTOFF AT Rc
            // WITH VERLET LISTS
            // ##################################
  
            // **************************
            // CALCULATE FORCES
            mainBox->physics.calc_LJ_forces_verletlists(*mainBox->neighborsverlet, mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //    - VERLET ALGORITHM
            mainBox->integrate.verlet(mainBox->sys);
            //    - VELOCITY VERLET ALGORITHM
            //integrate.velocity_verlet(physics, sys);
  
            // **************************
            // CHECK IF NEED TO UPDATE VERLET LISTS
            if (mainBox->neighborsverlet->check_verletlist(mainBox->sys))
            //if (mainBox->neighborsverlet->check_verletlist(mainBox->sys) || (mainBox->n%3==0))
            {
              //PRINT2("in update",n);
              mainBox->neighborsverlet->update_verletlist(mainBox->sys);
            }
            /*
             */
  
            break;
          }
          case 3:
          {
            // ##################################
            // HARD SPHERES DMD
            // ##################################
  
            // **************************
            // USE HARD SPHERE STEPWISE ALGORITHM
            mainBox->hardsphere.calc_hardsphere_stepwise(mainBox->sys);
  
            break;
          }
          case 4:
          {
            // ##################################
            // LANGEVIN DYNAMICS
            // ##################################
  
            // **************************
            // CALCULATE FORCES
  	  mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
            //mainBox->physics.calc_LJ_forces_verletlists(*mainBox->neighborsverlet, mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //  - LANGEVIN DYNAMICS
            mainBox->brownian.integrate_ermak(mainBox->sys);
  
            // **************************
            // CHECK IF NEED TO UPDATE VERLET LISTS
            /*
            if (mainBox->neighborsverlet->check_verletlist(mainBox->sys))
            {
              //PRINT2("in update",n);
              mainBox->neighborsverlet->update_verletlist(mainBox->sys);
            }
            
             */
  
            break;
          }
          case 5:
          {
            // ##################################
            // LANGEVIN DYNAMICS, INTEGRATION METHOD
            // WITH FORCE NOT CONSTANT
            // ##################################
  
            // **************************
            // CALCULATE FORCES HERE ONLY THE FIRST TIME
            if (mainBox->n==0)
            {
              mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
              //physics.calc_LJ_forces_verletlists(neighborsverlet, sys);
            }
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //  - LANGEVIN DYNAMICS STEP 1
            //    UPDATE POSITIONS
            mainBox->brownian.integrate_other_pt1(mainBox->sys);
  
            // **************************
            //  CALCULATE FORCES IN BETWEEN
            mainBox->physics.calc_LJ_forces_pot_cutoff(mainBox->sys);
            
            // **************************
            // INTEGRATE EQ. OF MOTION
            //  - LANGEVIN DYNAMICS STEP 2
            //    UPDATE VELOCITIES
            mainBox->brownian.integrate_other_pt2(mainBox->sys);
  
            // **************************
            // CHECK IF NEED TO UPDATE VERLET LISTS
            /*
            if (neighborsverlet.check_verletlist(sys))
            {
              //PRINT2("in update",n);
              neighborsverlet.update_verletlist(sys);
            }
             */
  
            break;
          }
          case 6:
          {
            // ##################################
            // MC OF LJ PARTICLES, NO ROTATION
            // ##################################
  
            // **************************
            // INITIALIZE THE POTENTIAL ENERGY BY
            // CALCULATING FORCES BUT ONLY ON THE FIRST STEP
            if (mainBox->n==0)
            {
              double virSum;
              mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
              // USING SHIFTED POTENTIAL INTRODUCES ALREADY
              // THE SHIFT AS AN ADDITIONAL TERM IN THE INITIAL
              // ENERGY
              //physics.calc_LJ_forces_pot_cutoff(2.5, sys);
            }
  
            // **************************
            // DO MC STEP
            double acc;
            acc = mainBox->mc.mc_step(mainBox->physics, mainBox->sys);
            cout <<  "accepted = " << acc 
            	<< " mc_step = " << mainBox->sys.mc_dr
            	<< "\n";
  
            // **************************
            // ADJUST MC STEP IF REQUESTED
            if (mainBox->sys.do_mc_adjust)
              mainBox->sys.mc_dr = mainBox->mc.adjust_mc_step_size(acc, mainBox->sys.mc_dr);
  
            break;
          }
          case 7:
          {
            // ##################################
            // MC OF LJ + XY PARTICLES
            // ##################################
  
            // **************************
            // INITIALIZE THE POTENTIAL ENERGY BY
            // CALCULATING FORCES BUT ONLY ON THE FIRST STEP
            if (mainBox->n==0)
            {
              // INITIALIZE ANGLES
              mainBox->sys.init_random_angles();
  
              // THIS IS IGNORING THE ISING TERM!
              double virSum;
              mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
              // USING SHIFTED POTENTIAL INTRODUCES ALREADY
              // THE SHIFT AS AN ADDITIONAL TERM IN THE INITIAL
              // ENERGY
              //physics.calc_LJ_forces_pot_cutoff(2.5, sys);
            }
  
            // **************************
            // DO MC STEP
            double acc;
            acc = mainBox->mc.mc_step_2D_angle(0, mainBox->physics, mainBox->sys);
            cout <<  "accepted = " << acc
                 <<  " mc_step = " << mainBox->sys.mc_dr
                 <<  " mc_theta = " << DEGREE(mainBox->sys.theta_o)
              << "\n";
  
            // **************************
            // ADJUST MC STEP IF REQUESTED
            if (mainBox->sys.do_mc_adjust)
               mainBox->sys.mc_dr = mainBox->mc.adjust_mc_step_size_theta(acc, mainBox->sys.mc_dr, mainBox->sys.theta_o);
  
            break;
          }
          case 8:
          {
            // ##################################
            // MC OF LJ + LL PARTICLES
            // ##################################
  
            // **************************
            // INITIALIZE THE POTENTIAL ENERGY BY
            // CALCULATING FORCES BUT ONLY ON THE FIRST STEP
            if (mainBox->n==0)
            {
              // INITIALIZE ANGLES
              mainBox->sys.init_random_angles();
  
              // THIS IS IGNORING THE ISING TERM!
              double virSum;
              mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
              // USING SHIFTED POTENTIAL INTRODUCES ALREADY
              // THE SHIFT AS AN ADDITIONAL TERM IN THE INITIAL
              // ENERGY
              //physics.calc_LJ_forces_pot_cutoff(2.5, sys);
            }
  
            // **************************
            // DO MC STEP
            double acc;
            acc = mainBox->mc.mc_step_2D_angle(1, mainBox->physics, mainBox->sys);
            cout <<  "accepted = " << acc
                 <<  " mc_step = " << mainBox->sys.mc_dr
                 <<  " mc_theta = " << DEGREE(mainBox->sys.theta_o)
              << "\n";
  
            // **************************
            // ADJUST MC STEP IF REQUESTED
            if (mainBox->sys.do_mc_adjust)
               mainBox->sys.mc_dr = mainBox->mc.adjust_mc_step_size_theta(acc, mainBox->sys.mc_dr, mainBox->sys.theta_o);
  
            break;
          }
          case 9:
          {
            // ##################################
            // MC OF LJ PARTICLES, NO ROTATION
            // NPT ENSEMBLE
            // ##################################
  
            // **************************
            // INITIALIZE THE POTENTIAL ENERGY BY
            // CALCULATING FORCES BUT ONLY ON THE FIRST STEP
            if (mainBox->n==0)
            {
              double virSum;
              mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
              // USING SHIFTED POTENTIAL INTRODUCES ALREADY
              // THE SHIFT AS AN ADDITIONAL TERM IN THE INITIAL
              // ENERGY
              //physics.calc_LJ_forces_pot_cutoff(2.5, sys);
            }
  
            // **************************
            // DO MC STEP
            double acc;
            acc = mainBox->mc.mc_step_NPT(mainBox->physics, mainBox->sys);
            cout <<  "accepted = " << acc
                 <<  " mc_step = " << mainBox->sys.mc_dr
              << "\n";
  
            // **************************
            // ADJUST MC STEP IF REQUESTED
            if (mainBox->sys.do_mc_adjust)
               mainBox->sys.mc_dr = mainBox->mc.adjust_mc_step_size(acc, mainBox->sys.mc_dr);
  
            break;
           }
           case 10:
           {
            // ##################################
            // POLYMER DYNAMICS WITH
            // REGULAR LJ MD, N*(N-1)/2 CALCULATION
            // ##################################
  
            // **************************
            // CALCULATE FORCES
            double virSum;
            mainBox->physics.calc_LJ_forces(virSum, mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //    - VERLET ALGORITHM
            //integrate.verlet(sys);
            //    - VELOCITY VERLET ALGORITHM
            //integrate.velocity_verlet(physics, sys);
            //    - VERLET ALGORITHM USING SHAKE CONSTRAINTS
            mainBox->integrate.verlet_polymers(virSum, mainBox->sys);
  
            break;
          }
          case 11:
          { 
            // ##################################
            // POLYMER DYNAMICS WITH
            // LJ POTENTIAL CUTOFF AT Rc
            // WITH VERLET LISTS
            // ##################################
  
            // **************************
            // CALCULATE FORCES
            mainBox->physics.calc_LJ_forces_verletlists(*mainBox->neighborsverlet, mainBox->sys);
  
            // **************************
            // INTEGRATE EQ. OF MOTION
            //    - VERLET ALGORITHM
            //integrate.verlet(sys);
            //    - VELOCITY VERLET ALGORITHM
            //integrate.velocity_verlet(physics, sys);
            //    - VERLET ALGORITHM USING SHAKE CONSTRAINTS
            double virSum;
            mainBox->integrate.verlet_polymers(virSum, mainBox->sys);
  
            // **************************
            // CHECK IF NEED TO UPDATE VERLET LISTS
            if (mainBox->neighborsverlet->check_verletlist(mainBox->sys))
            //if (mainBox->neighborsverlet->check_verletlist(mainBox->sys) || (mainBox->n%3==0))
            {
              //PRINT2("in update",n);
              mainBox->neighborsverlet->update_verletlist(mainBox->sys);
            }
            /*
             */
  
            break;
          }
  
          default:
            PRINT2("ERROR: NO CHOSEN DYNAMICS",mainBox->sys.dynamics);
            exit(0);
      }
  
  
      // **************************
      // UPDATE PRESSURE
      mainBox->sys.calc_pressure();
  
      // **************************
      // PERIODIC OUTPUT OF THERMODYNAMIC PROPERTIES
      ofstream out_f("results/thermo.dat",ios_base::app);
      mainBox->sys.output_properties(mainBox->n, mainBox->n*mainBox->sys.delta_t, out_f);
      out_f.close();
      //sys.output_position(5);
      ofstream out_p("results/totlinmom.dat",ios_base::app);
      mainBox->sys.output_total_linear_momentum(out_p);
      out_p.close();
      // ***************************
      // WRITE TO BUTTON WINDOW TOO
      valueOutputTemp->value( mainBox->sys.temperature );
  
      // **************************
      // CALCULATE MEAN SQUARE DISP. AND VACF
      if (mainBox->sys.do_vacf)
        mainBox->diff->accum(mainBox->n,mainBox->sys);
      // **************************
      // CALCULATE PAIR CORRELATION FUNCTION
      if (mainBox->sys.do_pcf)
        mainBox->pcf->accum(mainBox->n,mainBox->sys);
      // **************************
      // CALCULATE END-TO-END AND RG FUNCTION
      if (mainBox->sys.do_R)
      {
      	ofstream out_rg("results/rg.dat",ios_base::app);
      	ofstream out_rg2("results/rg2.dat",ios_base::app);
      	ofstream out_eoe("results/eoe.dat",ios_base::app);
      	ofstream out_eoe_vec("results/eoe_vec.dat",ios_base::app);
      	ofstream out_eoe2("results/eoe2.dat",ios_base::app);
          mainBox->R->calc(mainBox->sys, out_rg, out_rg2, out_eoe, out_eoe_vec, out_eoe2);
          out_rg.close();
          out_rg2.close();
          out_eoe.close();
          out_eoe_vec.close();
          out_eoe2.close();
      }
  
      // **************************
      // RECORD TAG PARTICLE'S LOCATION
      if (mainBox->sys.do_tag)
        mainBox->sys.record_tag_particles_position();
  
      // **************************
      // PRINT TIME
      //if (n % 10 ==0) PRINT5("time = ",n*sys.delta_t,": (",n*sys.delta_t/sys.total_time*100.,"%)");
  
      // **************************
      // INCREMENT LOOP COUNTER
      mainBox->n++;
      // INCREMENT SIMULATION TIME
      // - EXCLUDE FOR DMD THAT CALCULATES ITS OWN
      // - SIMULATION TIME
      if(mainBox->sys.dynamics!=3)
      {
          mainBox->sys.simulation_time = mainBox->n*mainBox->sys.delta_t;
      }
}

void anim(void*) {
  // TIME LOOP
  if (mainBox->sys.simulation_time <= mainBox->sys.total_time)
  {
  
    calc();
  
    // UPDATE WINDOW OBJECTS
    mainBox->redraw();
  
      // **************************
      // PUT TIME IN WINDOW BUTTON
      //simuTime->value(mainBox->n*mainBox->sys.delta_t);
      simuTime->value(mainBox->sys.simulation_time);
  
  
  #if BENCH_IT == 1
      // **************************
      //  OUTPUT EXECUTION TIME 
      if (mainBox->n % bench_h == 0)
      {
        cout << "  RUNNING AT "
          << float(time(NULL) - bench_t) / float(bench_h*mainBox->sys.delta_t)
          << " seconds per unit time\n";
        bench_t = time(NULL);
      }
  #endif
  
  
    // TIMEOUT FUNCTION
    if (flag)
      Fl::add_timeout(freq,anim);
    
  }
}

void showParamsWindow(void) {
  // READ FILE AND INIT PARAM WINDOW
  
  mainBox->DoDisplayLists();
  
  // =============================================
  // READ DEFAULT PARAMS FROM FILE
  char input_file[30] = "input_v09.txt";
  mainBox->sys.readFile(input_file);
  
  
  
  // ***********************************
  // PUT VALUES IN PARAM WINDOW
  valueLx->value(mainBox->sys.Lx);
  valueLy->value(mainBox->sys.Ly);
  valueLz->value(mainBox->sys.Lz);
  #if NDIM == 2
  valueLz->deactivate();
  #endif
  
  valueDeltaT->value(mainBox->sys.delta_t);
  valueDensity->value(mainBox->sys.density);
  valueTotalTime->value(mainBox->sys.total_time);
  valueTemperature->value(mainBox->sys.temperature);
  
  choiceDynamics->value(mainBox->sys.dynamics);
  valueRcCutoff->value(mainBox->sys.rc);
  valueRlCutoff->value(mainBox->sys.rl);
  
  initPosChoice->value(mainBox->sys.init_pos);
  valueThresholdInitRandPos->value(mainBox->sys.threshold_energy);
  initVelChoice->value(mainBox->sys.init_vel);
  valueTwoPartVel->value(mainBox->sys.two_part_vel);
  
  valueDampingConstant->value(mainBox->sys.damping_constant);
  valueVelRelaxationTime->value(1./mainBox->sys.damping_constant);
  
  valueTimeMeasure->value(mainBox->sys.time_meas);
  valueNHisPcf->value(mainBox->sys.nhis_pcf);
  
  checkDoVacf->value(mainBox->sys.do_vacf);
  checkDoPcf->value(mainBox->sys.do_pcf);
  checkDoR->value(mainBox->sys.do_R);
  
  valueMCStepSize->value(mainBox->sys.mc_dr);
  valueMCStepSizeTheta->value(mainBox->sys.theta_o);
  checkDoMCStepRescale->value(mainBox->sys.do_mc_adjust);
  valueXYJ->value(mainBox->sys.XY_J);
  
  checkSteepDescMinim->value( mainBox->sys.do_minimize );
  
  // DAMPING CONST STATUS
  if (choiceDynamics->value() != 4 && choiceDynamics->value() != 5)
  	valueDampingConstant->deactivate();
  // MC STEP SIZE STATUS
  if (choiceDynamics->value() != 6 && choiceDynamics->value() != 7 && choiceDynamics->value() != 8 && choiceDynamics->value() != 9)
  	valueMCStepSize->deactivate();
  	
  // POLYMER DATA
  checkPutPolymers->value( mainBox->sys.do_polymers );
  valueNumChains->value( mainBox->sys.num_chains );
  valueNumAtomsPerChain->value( mainBox->sys.atoms_per_chain );
  valueBondLength->value( mainBox->sys.length_bonds );
  
  setupWin->show();
}

void applyParamsButton(void) {
  applyParams();
  
  Inits();
}

void applyParams(void) {
  // APPLY PARAMETERS TO SYSTEM
  mainBox->sys.Lx = valueLx->value();
  mainBox->sys.Ly = valueLy->value();
  mainBox->sys.Lz = valueLz->value();
  
  mainBox->sys.delta_t = valueDeltaT->value();
  
  // IF THIS IS A TWO-PARTICLE SYSTEM, THE DENSITY
  // WILL BE FIXED BELOW, IN apply_inits()
  mainBox->sys.density = valueDensity->value();
  
  mainBox->sys.total_time = valueTotalTime->value();
  mainBox->sys.temperature = valueTemperature->value();
  mainBox->sys.requested_temperature = mainBox->sys.temperature;
  
  mainBox->sys.dynamics = choiceDynamics->value();
  mainBox->sys.rc = valueRcCutoff->value();
  mainBox->sys.rl = valueRlCutoff->value();
  
  mainBox->sys.init_pos = initPosChoice->value();
  mainBox->sys.threshold_energy = valueThresholdInitRandPos->value();
  
  mainBox->sys.damping_constant = valueDampingConstant->value();
  
  mainBox->sys.time_meas = valueTimeMeasure->value();
  mainBox->sys.nhis_pcf = valueNHisPcf->value();
  
  mainBox->sys.do_vacf = checkDoVacf->value();
  mainBox->sys.do_pcf = checkDoPcf->value();
  mainBox->sys.do_R = checkDoR->value();
  
  mainBox->sys.init_vel = initVelChoice->value();
  mainBox->sys.two_part_vel = valueTwoPartVel->value();
  
  mainBox->sys.mc_dr = valueMCStepSize->value();
  mainBox->sys.theta_o = valueMCStepSizeTheta->value();
  mainBox->sys.do_mc_adjust = checkDoMCStepRescale->value();
  mainBox->sys.XY_J = valueXYJ->value();
  
  mainBox->sys.do_minimize = checkSteepDescMinim->value();
  
  //POLYMERS
  mainBox->sys.do_polymers = checkPutPolymers->value(  );
  mainBox->sys.num_chains = valueNumChains->value(  );
  mainBox->sys.atoms_per_chain = valueNumAtomsPerChain->value(  );
  mainBox->sys.length_bonds = valueBondLength->value(  );
  
  // WRITE TO FILES AND CLOSE
  ofstream warn("results/warnings.txt");
  ofstream params("results/params.txt");
  
  // =============================================
  //  WRITE INITIAL PARAMETERS
  char dummy8[40] = "results/input.txt";
  mainBox->sys.writeFile(dummy8);
  // =============================================
  
  mainBox->sys.apply_inits(warn);
  valueDensity->value(mainBox->sys.density);
  
  params << mainBox->sys;
  
  params.close();
  warn.close();
  
  // ACTIVATE AND DEACTIVATE BUTTON
  stepButton->activate();
  runButton->activate();
  applyParamBut->deactivate();
  setupWin->hide();
  setupParamsMenu->deactivate();
  writeVelsMenu->activate();
  
  // OTHER BUTTONS
  valueTotNumParticles->value(mainBox->sys.N);
  valueOutputReqTemp->value( mainBox->sys.requested_temperature );
}

void Inits(void) {
  // =============================================
    // INITIALIZE POSITIONS : 1 - LATTICE, 2 - RANDOM WITH ENERGY CHECK
    mainBox->sys.init_positions(mainBox->sys.init_pos);
  
    // =============================================
    // VERLET NEIGHBOR LIST
    mainBox->neighborsverlet = new verletlist(mainBox->sys.N, mainBox->sys.rc, mainBox->sys.rl);
  
    // =============================================
    // OPTIONAL OUTPUTS TO VERIFY INITIAL SETUP 
    //
    //char dummy[40] = "results/out_init_r.xyz";
    //sys.output_positions(1,dummy);
    //sys.output_position(5);
    //
    //char dummy2[40] = "results/out_init_v.dat";
    //sys.output_velocities(dummy2);
    //
    //sys.output_total_linear_momentum();
    //
    //char dummy7[40] = "results/enrg_lndscp.dat";
    //mainBox->physics.energy_landscape(mainBox->sys,dummy7);
  
    // =============================================
    // DEFINE CONFINED SYSTEM
  #if CONFINED == 1
    double min_L = MIN(mainBox->sys.Lx,mainBox->sys.Ly);
    min_L = MIN(min_L,mainBox->sys.Lz);
    double rad;
    //rad = min_L+5.;
    //rad = min_L / 2.;
    //rad = min_L / 3.;
    //rad = min_L / 4.;
    //rad = min_L / 6.;
    //rad = min_L / 8.;
    rad = 3.75;
    mainBox->sys.fix_atoms_beyond_radius(rad);
    PRINT2("Confined to radius = ",rad);
  #endif
  
    // =============================================
    // OPTIONAL MINIMIZATION STEP
    //int    particle  = 5;
    double step_size = 0.1;
    double criterium = 1.0e-4;
    // - MOVE ONE PARTICLE
    //minimize.steepest_descents_arbitrary_step_one_particle(particle, step_size, criterium, physics, sys);
    // - MOVE ALL PARTICLES
    int steps_min = 1; 
    if (mainBox->sys.do_minimize)
    {
      for (int i=0; i<steps_min; i++)
      {
        mainBox->minimize.steepest_descents_arbitrary_step(step_size, criterium, mainBox->physics, mainBox->sys);
      }
    }    
    // - PRINT POSITIONS AFTER MINIMIZING
    //char dummy3[40] = "out_minim_r.xyz";
    //sys.output_positions(1,dummy3);
  
    // =============================================
    // INITIALIZE RANDOM VELOCITIES
    mainBox->sys.init_velocities(mainBox->sys.init_vel);
    //char dummy6[40] = "results/out_init_v.dat";
    //sys.output_velocities(dummy6);
  
    // =============================================
    // CREATE DIFFUSION OBJECT
    mainBox->diff = new diffusion(mainBox->sys);
    // CREATE PAIR CORRELATION FUNCTION OBJECT
    mainBox->pcf = new paircorrfunc(mainBox->sys);
    // CREATE END-TO-END AND RG FUNCTION OBJECT
    mainBox->R = new R_meas(mainBox->sys);
  
    // =============================================
    // UPDATE VERLET LISTS FOR THE FIRST STEP
    mainBox->neighborsverlet->update_verletlist(mainBox->sys);
  
    // =============================================
    // INITIALIZE TAG PARTICLE ARRAY
    mainBox->sys.reset_tag_pos();
  
    // =============================================
    // MAIN TIME LOOP
    mainBox->n       = 0;
    mainBox->sys.simulation_time = 0.;
    
    
    // ADVANCE BY ONE TIMESTEP TO SHOW PARTICLES
    Step();
}

void showToolsWindow(void) {
  // INITIALIZE BUTTONS AND BOXES
  valueTagParticle->value( mainBox->sys.tag_particle );
  checkTagPart->value( mainBox->sys.do_tag );
  
  toolsWin->show();
}

void applyCheckTagParticle(void) {
  // CHECK THAT PARTICLE ID IS WITHIN BOUNDS
  int cp = valueTagParticle->value();
  if (cp >=0 && cp < mainBox->sys.N)
  {
  
  // RESET ARRAY WHENEVER HIT THE CHECK BUTTON
  mainBox->sys.reset_tag_pos();
  
  // GET VALUES
  mainBox->sys.tag_particle = valueTagParticle->value();
  mainBox->sys.do_tag = checkTagPart->value();
  
  }
  else
  {
  
  checkTagPart->value(0);
  cout << "Tag Particle out of range " << cp << "\n";
  
  }
}

void applyRescaleVels(void) {
  // RESCALE VELOCITIES TO APPROXIMATE REQUESTED TEMPERATURE
  mainBox->sys.scale_vel();
}

void choiceDynamicsHideButtons(void) {
  // LANGEVIN DAMPING CONST
  if (choiceDynamics->value()!=4 && choiceDynamics->value()!=5)
    valueDampingConstant->deactivate();
  else
    valueDampingConstant->activate();
    
  // MC STEP SIZE
  if (choiceDynamics->value()!=6 && choiceDynamics->value()!=7 && choiceDynamics->value()!=8)
    valueMCStepSize->deactivate();
  else
    valueMCStepSize->activate();
}

void WritePositions(int) {
  char *a = fl_file_chooser("Write Positions","*.xyz",NULL);
  
  if (a!=NULL)
  {
  	// WRITE REAL (NOT IMAGE) POISITIONS
  	// TO FILE
  	mainBox->sys.output_positions(0,a);
  }
}

void ReadPositions(void) {
  char *a = fl_file_chooser("Read Positions","*.xyz",NULL);
  
  if (a!=NULL)
  {
  	// READ REAL POSITIONS FROM FILE
  	mainBox->sys.input_positions(a);
  }
}

void saveAllVels(void) {
  char *a = fl_file_chooser("Save Velocities",NULL,NULL);
  
  if (a!=NULL)
  {
  	mainBox->sys.output_velocities(a);
  }
}

void writeTagTrajectory(void) {
  // WRITE TRAJECTORY TO FILE
  mainBox->sys.write_tag_pos();
}

void Pause(void) {
  flag = 0;
}

void Step(void) {
  flag = 1;
  
  
  Fl::add_timeout(freq,anim);
  
  flag = 0;
}

void Run(void) {
  flag = 1;
  
  
  // RUN
  Fl::add_timeout(freq,anim);
}

void ExitFunc(void) {
  //if (!fl_ask("Quit?")) return;
  exit(0);
}
